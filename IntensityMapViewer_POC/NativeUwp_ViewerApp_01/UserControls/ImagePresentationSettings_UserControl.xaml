<UserControl
    x:Class="NativeUwp_ViewerApp_01.ImagePresentationSettings_UserControl"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="using:NativeUwp_ViewerApp_01"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d"
    d:DesignHeight="380"
    d:DesignWidth="200"
  >

  <!-- 
  <UserControl.Resources>
    <ResourceDictionary>
      <local:EnumToStringConverter x:Key="enumToStringConverter" />
    </ResourceDictionary>
  </UserControl.Resources>
  -->

    <Grid Background="LightYellow">

      <StackPanel Orientation="Vertical">
      
       <TextBox Text="Image presentation settings" HorizontalAlignment="Center"/>

       <!-- 
       <ComboBox Header="Colour map" Width="160" >
         <x:String>GreyScale</x:String> 
         <x:String>Jet</x:String> 
       </ComboBox>
       -->

       <!-- 
         The proper value is not shown until the selection is changed
         ... even though the ColourMapOption we're binding to does have 
         a valid value ...
         None of these experiments has worked :
         SelectedItem="{x:Bind ViewModel.ColourMapOption, Mode=TwoWay}"
         SelectedValue="{x:Bind ViewModel.ColourMapOption, Mode=TwoWay}"
         SelectedIndex="0"
         IsSynchronizedWithCurrentItem="True" [ null reference exception !! ]
         Tried this, doesn't even compile :
         https://alski.net/2016/07/21/uwp-combobox-selecteditem-doesnt-bind/
       
         Apparently you have to set ItemsSource first
         see https://alski.net/2016/07/21/uwp-combobox-selecteditem-doesnt-bind/

         Another post says
         Trust me, ComboBox and enum in UWP is a bad idea. 
         Save yourself some time, don't use enum on a combobox in UWP.

       -->
       <!-- 
      <ComboBox Header="Colour map" Width="160" 
         ItemsSource="{x:Bind ColourMapOptions}"
         SelectedItem="{x:Bind ViewModel.ColourMapOption, Mode=TwoWay}"
         SelectedValue="{x:Bind Path=ViewModel.ColourMapOption, Mode=TwoWay}"
         DisplayMemberPath="Name"
         SelectedValuePath="Value"
       />
       -->

       <!-- 
         This works correctly, but it's a truly horrible solution
         that provides a 2nd 'shadow' property of the enum type
         in the ViewModel, of type String. Necessary to explicitly
         guard against infinite recursion triggered by changes.
       -->
      <ComboBox Header="Colour map VM" Width="160" 
         ItemsSource="{x:Bind ViewModel.ColourMapOptionNames}"
         SelectedValue="{x:Bind ViewModel.ColourMapOptionName, Mode=TwoWay}"
       />

       <!-- 
       This version with a Converter and 'SelectedItem' works fully !!
       We're having to discover the options by invoking 'GetOptionNamesForType'
       where we supply the current value of the enum. That works fine, but potentially
       that value could be null (??) and it would be better to query the TYPE of the enum.
       Something like the following - but there doesn't seem to be a way of
       passing a 'Type' into a function, in XAML ...
       ItemsSource="{x:Bind GetOptionNamesForEnumType(local:MySimpleEnum)}"
       -->
      <ComboBox Header="Colour map 00a" Width="160" 
         ItemsSource="{x:Bind GetOptionNamesForType(ViewModel.ColourMapOption)}"
         SelectedItem="{x:Bind ViewModel.ColourMapOption, Converter={StaticResource enumToStringConverter}, Mode=TwoWay}"
       />

       <!-- 
       This variant using 'SelectedValue' leaves the initial value unset ...
       -->
      <ComboBox Header="Colour map 00b" Width="160" 
         ItemsSource="{x:Bind ColourMapOptionNames}"
         SelectedValue="{x:Bind ViewModel.ColourMapOption, Converter={StaticResource enumToStringConverter}, Mode=TwoWay}"
       />

      <!-- 
      // Compile error : Unexpected BindBack found
      <ComboBox Header="Colour map xx" Width="160" 
         ItemsSource="{x:Bind ColourMapOptionNames}"
         SelectedItem="{x:Bind ColourMapOptionName, Mode=TwoWay, BindBack=SetColourMapOptionFromName}"
      />
      -->

      <!-- 
      At last, something that works.
      https://github.com/thomasclaudiushuber/Uwp-x-Bind-BindBack-Sample/blob/master/UwpBindBackSample/MainPage.xaml
      This works correctly in all respects, but the 'BindBack' function is explicitly setting
      the ViewModel property and returning void ; it can't be made into a generic helper.
      -->
      <ComboBox Header="Colour map 01" Width="160" 
         ItemsSource="{x:Bind ColourMapOptionNames}"
         SelectedValue="{x:Bind GetColourMapOptionName(ViewModel.ColourMapOption), BindBack=SetColourMapOptionFromName, Mode=TwoWay}"
       />

      <!-- 
      This seemed like a better solution but it doesn't work. 
      1. The initial value doesn't get set
      2. Although we're returning a converted value from the
         BindBack function, this isn't getting set on the ViewModel property.
         OF COURSE THIS IS OBVIOUS WHEN YOU LOOK AT THE GENERATED CODE,
         THE RETURN RESULT IS BEING DISCARDED. THIS FUNCTION IS CLEARLY MEANT
         TO PROPAGATE AN UPDATED VALUE FROM THE OBJECT PASSED IN, BUT IT ISN'T
         GIVEN ACCESS TO THE PROPERTY IT'S MEANT TO BE WRITING TO. CRAP.
      -->
      <ComboBox Header="Colour map 02" Width="160" 
         ItemsSource="{x:Bind GetOptionNamesForType(ViewModel.ColourMapOption)}"
         SelectedValue="{x:Bind GetColourMapOptionName(ViewModel.ColourMapOption), BindBack=GetColourMapOptionFromName, Mode=TwoWay}"
       />

      <!-- 
      Same as above, using SelectedItem instead of SelectedValue. Again, doesn't work.
      1. The initial value IS NOW GETTING SET
      2. BUT ... Although we're returning a converted value from the
         BindBack function, this isn't getting set on the ViewModel property.
      -->
      <ComboBox Header="Colour map 03" Width="160" 
         ItemsSource="{x:Bind GetOptionNamesForType(ViewModel.ColourMapOption)}"
         SelectedItem="{x:Bind GetColourMapOptionName(ViewModel.ColourMapOption), BindBack=GetColourMapOptionFromName, Mode=TwoWay}"
       />

      <ComboBox Header="Normalisation mode" Width="160" 
         ItemsSource="{x:Bind GetOptionNamesForType(ViewModel.NormalisationMode)}"
         SelectedItem="{x:Bind ViewModel.NormalisationMode, Converter={StaticResource enumToStringConverter}, Mode=TwoWay}"
       />

       <!-- The 'CanSetNormalisationValue' is definitely getting changed, -->
       <!-- and the ViewModel is publishing the change ... but the 'IsEnabled' -->
       <!-- property is NOT getting updated ... -->
       <Slider 
         x:Name="m_normalisationValueSlider"
         HorizontalAlignment="Left"
         Minimum="0" Maximum="255" Width="160" Header="Normalisation value"
         Value="{x:Bind ViewModel.NormalisationValue, Mode=OneWay}"
         ValueChanged="Slider_ValueChanged"
         IsEnabled="{x:Bind ViewModel.CanSetNormalisationValue, Mode=OneWay}"
         IsEnabledChanged="m_normalisationValueSlider_IsEnabledChanged"
       />

       <Button 
         Content="Just testing" 
         IsEnabled="{x:Bind ViewModel.CanSetNormalisationValue, Mode=OneWay}"
       />

       <local:NumericValueEditor_UserControl />

     </StackPanel>

    </Grid>
</UserControl>
